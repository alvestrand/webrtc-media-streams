<pre class='metadata'>
Title: WebRTC Encoded Transform
Shortname: webrtc-encoded-transform
Level: None
Status: ED
Group: webrtc
Repository: w3c/webrtc-encoded-transform
URL: https://w3c.github.io/webrtc-encoded-transform/
Editor: Harald Alvestrand, Google https://google.com, hta@google.com
Editor: Guido Urdaneta, Google https://google.com, guidou@google.com
Editor: Youenn Fablet, Apple https://www.apple.com, youenn@apple.com
Abstract: This API defines an API surface for manipulating the bits on
Abstract: {{MediaStreamTrack}}s being sent via an {{RTCPeerConnection}}.
Markup Shorthands: css no, markdown yes
</pre>
<pre class=link-defaults>
spec:webidl; type:dfn; text:resolve
</pre>
<pre class=biblio>
{
  "WEB-CODECS": {
     "href":
     "https://github.com/WICG/web-codecs/blob/master/explainer.md",
     "title": "Web Codecs explainer"
   }
}
</pre>
<pre class=link-defaults>
spec:streams; type:interface; text:ReadableStream
</pre>

# Introduction # {#introduction}

The [[WEBRTC-NV-USE-CASES]] document describes several functions that
can only be achieved by access to media (requirements N20-N22),
including, but not limited to:
* Funny Hats
* Machine Learning
* Virtual Reality Gaming

These use cases further require that processing can be done in worker
threads (requirement N23-N24).

Furthermore, the "trusted JavaScript cloud conferencing" use case
requires such processing to be done on encoded media, not just the raw
media.

This specification gives an interface inspired by [[WEB-CODECS]] to
provide access to such functionality while retaining the setup flow of
RTCPeerConnection.

This iteration of the specification provides access to encoded media,
which is the output of the encoder part of a codec and the input to the
decoder part of a codec.

# Terminology # {#terminology}

# Specification # {#specification}

The Streams definition doesn't use WebIDL much, but the WebRTC spec does.
This specification shows the IDL extensions for WebRTC.

It uses an additional API on {{RTCRtpSender}} and {{RTCRtpReceiver}} to
insert the processing into the pipeline.

<pre class="idl">
// New dictionary
dictionary RTCInsertableStreams {
    ReadableStream readable;
    WritableStream writable;
};

typedef (SFrameTransform or RTCRtpScriptTransform) RTCRtpTransform;

// New methods for RTCRtpSender and RTCRtpReceiver
partial interface RTCRtpSender {
    attribute RTCRtpTransform? transform;
};

partial interface RTCRtpReceiver {
    attribute RTCRtpTransform? transform;
};
</pre>

## Extension operation ## {#operation}

At the time when a codec is initialized as part of the encoder, and the
corresponding flag is set in the {{RTCPeerConnection}}'s {{RTCConfiguration}}
argument, ensure that the codec is disabled and produces no output.


### Stream creation ### {#stream-creation}

Each {{RTCRtpSender}} or {{RTCRtpReceiver}} has its own <dfn>media thread</dfn> on which media flows,
from a source on which to read encoded data to a sink on which to write encoded data.
The source is the packetizer for {{RTCRtpSender}} and the decoder for {{RTCRtpReceiver}}.
It operates in the [=media thread=] and is modeled as a {{ReadableStream}}.
The sink is the encoder for {{RTCRtpSender}} and the depacketizer for {{RTCRtpReceiver}}.
It operates in the [=media thread=] and is modeled as a {{WritableStream}}.

At construction of each {{RTCRtpSender}} or {{RTCRtpReceiver}}, run the following steps:
1. Initialize [=this=].`[[transform]]` to <code>null</code>.
1. Initialize [=this=].`[[lastReceivedFrameTimestamp]]` to zero.
1. Initialize [=this=].`[[pipeToController]]` to <code>null</code>.
1. Initialize [=this=].`[[source]]` to a new {{ReadableStream}}.
1. <a dfn for="ReadableStream">Set up</a> [=this=].`[[source]]`. [=this=].`[[source]]` is provided frames using the [=readSourceData=] algorithm given |this| as parameter.
1. Initialize [=this=].`[[sink]]` to a new {{WritableStream}}.
1. <a dfn for="WritableStream">Set up</a> [=this=].`[[sink]]` with its [=WritableStream/set up/writeAlgorithm=] set to [=writeSinkData=] given |this| as parameter.
1. [=Queue a task=] to run the following step:
    1. [=Queue a task=] on [=this=]'s media thread to run the following steps:
        1. If [=this=].`[[pipeToController]]` is not null, abort these steps.
        1. Set [=this=].`[[pipeToController]]` to a new {{AbortController}}.
        <!-- FIXME: Use pipeTo algorithm when available. -->
        1. Call <a href="https://streams.spec.whatwg.org/#readable-stream-pipe-to">pipeTo</a> with [=this=].`[[source]]`,
            [=this=].`[[sink]]`, preventClose equal to true, preventAbort equal to true, preventCancel equal to true and [=this=].`[[pipeToController]]`.signal.

### Stream processing ### {#stream-processing}

The <dfn>readSourceData</dfn> algorithm given |rtcObject| runs the following steps in the [=media thread=]:
1. Wait for a frame to be produced by |rtcObject|'s encoder if it is a {{RTCRtpSender}} or |rtcObject|'s packetizer if it is a {{RTCRtpReceiver}}.
1. Let |frame| be the newly produced frame.
1. Set |frame|.`[[owner]]` to |rtcObject|.
1. [=ReadableStream/Enqueue=] |frame| in |rtcObject|.`[[source]]`.

The <dfn>writeSinkData</dfn> algorithm given |rtcObject| and |frame| runs the following steps in the [=media thread=]:
1. If |frame|.`[[owner]]` is not equal to |rtcObject|, abort these steps and return [=a promise resolved with=] undefined. A processor cannot create frames, or move frames between streams.
1. If the |frame|'s {{RTCEncodedVideoFrame/timestamp}} is equal to or larger than |rtcObject|.`[[lastReceivedFrameTimestamp]]`, abort these steps and return [=a promise resolved with=] undefined. A processor cannot reorder frames, although it may delay them or drop them.
1. Set |rtcObject|.`[[lastReceivedFrameTimestamp]]` to the |frame|'s {{RTCEncodedVideoFrame/timestamp}}.
1. Enqueue the frame for processing as if it came directly from the encoded data source, by running one of the following steps in the [=media thread=]:
    * If |rtcObject| is a {{RTCRtpSender}}, enqueue it to |rtcObject|'s packetizer.
    * If |rtcObject| is a {{RTCRtpReceiver}}, enqueue it to |rtcObject|'s decoder.
5. Return [=a promise resolved with=] undefined.

## Extension attribute ## {#attribute}

A RTCRtpTransform has two private slots called `[[readable]]` and `[[writable]]`.

The <dfn attribute for="RTCRtpSender,RTCRtpReceiver">transform</dfn> getter steps are:
1. Return [=this=].`[[transform]]`.

The `transform` setter steps are:
1. Let |transform| be the argument to the setter.
1. If |transform| is not <code>null</code>, run the following steps:
    1. If |transform|.`[[readable]]` is [=ReadableStream/locked=], [=throw=] a {{TypeError}}. 
    1. [=WritableStream/getting a writer|Get a writer=] for |transform|.`[[writable]]`.
    1. [=ReadableStream/getting a reader|Get a reader=] for |transform|.`[[readable]]`.
1. [=Queue a task=] in [=this=]'s [=media thread=] to run the following steps:
    1. let |pipeToController| be a new {{AbortController}}.
    1. Let |internalTransform| be an [=identity transform stream=].
    1. If |transform| is an {{SFrameTransform}}, set |internalTransform| to an [=SFrame transform stream=] given |transform|.
    1. If |transform| is an {{RTCRtpScriptTransform}}, set |internalTransform| to a [=script transform stream=] given |transform|.
    1. Run the [=chain transform algorithm=] with [=this=], |internalTransform|.`[[readable]]`, |internalTransform|.`[[writable]]` and |pipeToController|.
1. Set [=this=].`[[transform]]` to |transform|.

The <dfn>chain transform algorithm</dfn>, given |rtcObject|, |readable|, |writable| and |pipeToController|, runs these steps in rtcObject's [=media thread=]:
1. If |pipeToController| [=AbortSignal/aborted flag=] is true, abort these steps.
1. If |rtcObject|.`[[pipeToController]]` is not <code>null</code>, run the following steps:
    1. [=AbortSignal/Add=] the [=chain transform algorithm=] with |rtcObject|, |readable|, |writable| and |pipeToController|, to |rtcObject|.`[[pipeToController]]`.signal.
    1. [=AbortSignal/signal abort=] |rtcObject|.`[[pipeToController]]`.signal.
1. Else run the following steps:
    <!-- FIXME: Use pipeTo algorithm when available. -->
    1. Call <a href="https://streams.spec.whatwg.org/#readable-stream-pipe-to">pipeTo</a> with |rtcObject|.`[[source]]`, |writable|, preventClose equal to false, preventAbort equal to false, preventCancel equal to true and |pipeToController|.signal.
    1. Call <a href="https://streams.spec.whatwg.org/#readable-stream-pipe-to">pipeTo</a> with |readable|, |rtcObject|.`[[sink]]`, preventClose equal to true, preventAbort equal to true, preventCancel equal to false and |pipeToController|.signal.
1. Set |rtcObject|.`[[pipeToController]]` to |pipeToController|.

This algorithm is defined so that transforms can be updated dynamically.
There is no guarantee on which frame will happen the switch from the previous transform to the new transform.
If a new transform overwrites an old transform, all frames will go either through the old or the new transform from the source to the sink.

If a web application sets the transform synchronously at creation of the {{RTCRtpSender}} (for instance when calling addTrack), the transform will receive the first frame generated by the {{RTCRtpSender}}'s encoder.
Similarly, if a web application sets the transform synchronously at creation of the {{RTCRtpReceiver}} (for instance when calling addTrack, or at track event handler), the transform will receive the first full frame generated by the {{RTCRtpReceiver}}'s packetizer.

# SFrameTransform # {#sframe}

<xmp class="idl">
enum SFrameTransformRole {
    "encrypt",
    "decrypt"
};

dictionary SFrameTransformOptions {
    SFrameTransformRole role = "encrypt";
};

typedef [EnforceRange] unsigned long long SmallCryptoKeyID;
typedef (SmallCryptoKeyID or bigint) CryptoKeyID;

[Exposed=(Window,DedicatedWorker)]
interface SFrameTransform {
    constructor(optional SFrameTransformOptions options = {});
    Promise<undefined> setEncryptionKey(CryptoKey key, optional CryptoKeyID keyID);
};
SFrameTransform includes GenericTransformStream;
</xmp>

The <dfn constructor for="SFrameTransform" lt="SFrameTransform(options)"><code>new SFrameTransform(<var>options</var>)</code></dfn> constructor steps are:
1. Set |this|.`[[role]]` to |options|["{{SFrameTransformOptions/role}}"].
1. Let |sframeTransform| be a [=SFrame transform stream=] given |this|.
1. Set |this|.`[[readable]]` to |sframeTransform|.`[[readable]]`.
1. Set |this|.`[[writable]]` to |sframeTransform|.`[[writable]]`.

## Algorithms ## {#sframe-transform-algorithms}

A <dfn>SFrame transform stream</dfn> given |transform| is created by running the following steps:
1. Let |transformAlgorithm| be an algorithm which takes a |frame| as input and runs the [=SFrame transform algorithm=] with |transform| and |frame|.
1. Set |transform|.`[[sframeTransform]]` to a new {{TransformStream}}.
1.  [=TransformStream/Set up=] |transform|.`[[sframeTransform]]` with [=TransformStream/set up/transformAlgorithm=] set to |transformAlgorithm|.
1. Return |sframeTransform|.

The <dfn>SFrame transform algorithm</dfn>, given |sframeTransform| and |frame|, runs these steps:
1. Let |role| be |sframeTransform|.`[[role]]`.
1. If |frame|.`[[owner]]` is a {{RTCRtpSender}}, set |role| to 'encrypt'.
1. If |frame|.`[[owner]]` is a {{RTCRtpReceiver}}, set |role| to 'decrypt'.
1. Let |data| be undefined.
1. If |frame| is a {{BufferSource}}, set |data| to |frame|.
1. If |frame| is a {{RTCEncodedAudioFrame}}, set |data| to |frame|.{{RTCEncodedAudioFrame/data}}
1. If |frame| is a {{RTCEncodedVideoFrame}}, set |data| to |frame|.{{RTCEncodedVideoFrame/data}}
1. If |data| is undefined, abort these steps.
1. Let |buffer| be the result of running the SFrame algorithm with |data| and |role| as parameters. This algorithm is defined by the <a href="https://datatracker.ietf.org/doc/draft-omara-sframe/">SFrame specification</a> and returns an {{ArrayBuffer}}.
1. If |frame| is a {{BufferSource}}, set |frame| to |buffer|.
1. If |frame| is a {{RTCEncodedAudioFrame}}, set |frame|.{{RTCEncodedAudioFrame/data}} to |buffer|.
1. If |frame| is a {{RTCEncodedVideoFrame}}, set |frame|.{{RTCEncodedVideoFrame/data}} to |buffer|.
1. [=ReadableStream/Enqueue=] |frame| in |sframeTransform|.`[[transform]]`.

## Methods ## {#sframe-transform-methods}
The <dfn method for="SFrameTransform">setEncryptionKey(|key|, |keyID|)</dfn> method steps are:
1. Let |promise| be [=a new promise=].
1. If |keyID| is a {{bigint}} which cannot be represented as a integer between 0 and 2<sup>64</sup>-1 inclusive, [=reject=] |promise| with a {{RangeError}} exception.
1. Otherwise, [=in parallel=], run the following steps:
    1. Set |key| with its optional |keyID| as key material to use for the [=SFrame transform algorithm=], as defined by the <a href="https://datatracker.ietf.org/doc/draft-omara-sframe/">SFrame specification</a>.
    1. If setting the key material fails, [=reject=] |promise| with an {{InvalidModificationError}} exception and abort these steps.
    1. [=Resolve=] |promise| with undefined.
1. Return |promise|.


# RTCRtpScriptTransform # {#scriptTransform}

<pre class="idl">
// New enum for video frame types. Will eventually re-use the equivalent defined
// by WebCodecs.
enum RTCEncodedVideoFrameType {
    "empty",
    "key",
    "delta",
};

dictionary RTCEncodedVideoFrameMetadata {
    long long frameId;
    sequence&lt;long long&gt; dependencies;
    unsigned short width;
    unsigned short height;
    long spatialIndex;
    long temporalIndex;
    long synchronizationSource;
    sequence&lt;long&gt; contributingSources;
};

// New interfaces to define encoded video and audio frames. Will eventually
// re-use or extend the equivalent defined in WebCodecs.
[Exposed=(Window,DedicatedWorker)]
interface RTCEncodedVideoFrame {
    readonly attribute RTCEncodedVideoFrameType type;
    readonly attribute unsigned long long timestamp;
    attribute ArrayBuffer data;
    RTCEncodedVideoFrameMetadata getMetadata();
};

dictionary RTCEncodedAudioFrameMetadata {
    long synchronizationSource;
    sequence&lt;long&gt; contributingSources;
};

[Exposed=(Window,DedicatedWorker)]
interface RTCEncodedAudioFrame {
    readonly attribute unsigned long long timestamp;
    attribute ArrayBuffer data;
    RTCEncodedAudioFrameMetadata getMetadata();
};


// New interfaces to expose JavaScript-based transforms.

[Exposed=DedicatedWorker]
interface RTCTransformEvent : Event {
    readonly attribute RTCRtpScriptTransformer transformer;
};

partial interface DedicatedWorkerGlobalScope {
    attribute EventHandler onrtctransform;
};

[Exposed=DedicatedWorker]
interface RTCRtpScriptTransformer {
    readonly attribute ReadableStream readable;
    readonly attribute WritableStream writable;
    readonly attribute any options;
};

[Exposed=Window]
interface RTCRtpScriptTransform {
    constructor(Worker worker, optional any options, optional sequence&lt;object&gt; transfer);
};
</pre>

## Operations ## {#RTCRtpScriptTransform-operations}
The <dfn constructor for="RTCRtpScriptTransform" lt="RTCRtpScriptTransform(worker, options)"><code>new RTCRtpScriptTransform(|worker|, |options|, |transfer|)</code></dfn> constructor steps are:
1. Set |this|.`[[worker]]` to |worker|.
1. Let |serializedOptions| be the result of [$StructuredSerializeWithTransfer$](|options|, |transfer|).
1. [=Queue a task=] on the DOM manipulation [=task source=] |worker|'s global scope to run the following steps:
    1. Let transformer be a new {{RTCRtpScriptTransformer}}.
    1. Let |transformerOptions| be the result of [$StructuredDeserialize$](|serializedOptions|, the current Realm).
    1. Set |transformer|.`[[options]]` to |transformerOptions|.
    1. Let |transformer|.`[[t1]]` to an [=identity transform stream=].
    1. Let |transformer|.`[[t2]]` to an [=identity transform stream=].
    1. Set |transformer|.`[[readable]]` to |transformer|.`[[t1]]`.`[[readable]]`.
    1. Set |transformer|.`[[writable]]` to |transformer|.`[[t2]]`.`[[writable]]`.
    1. Let |event| be the result of [=creating an event=] with {{RTCTransformEvent}}.
    1. Set |event|.type attribute to "rtctransform".
    1. Set |event|.transformer to |transformer|.
    1. Set |this|.`[[transformer]]` to |transformer|.
    1. [=Dispatch=] |event| to |worker|’s global scope.

// FIXME: Describe error handling (worker closing flag true at RTCRtpScriptTransform creation time. And worker being terminated while transform is processing data).

A <dfn>script transform stream</dfn> given |transform| is created by running the following steps:
1. Set |t1| to an [=identity transform stream=].
1. Set |t2| to an [=identity transform stream=].
1. Set |scriptTransform|.`[[writable]]` to |t1|.`[[writable]]`.
1. Set |scriptTransform|.`[[readable]]` to |t2|.`[[readable]]`.
1. Let |serializedReadable| be the result of [$StructuredSerializeWithTransfer$](|t1|.`[[readable]]`, « |t1|.`[[readable]]` »).
1. Let |serializedWritable| be the result of [$StructuredSerializeWithTransfer$](|t2|.`[[writable]]`, « |t2|.`[[writable]]` »).
1. [=Queue a task=] on the DOM manipulation [=task source=] |transform|.`[[worker]]`'s global scope to run the following steps:
    1. Let |readable| be the result of [$StructuredDeserialize$](|serializedReadable|, the current Realm).
    1. Let |writable| be the result of [$StructuredDeserialize$](|serializedWritable|, the current Realm).
    1. Call <a href="https://streams.spec.whatwg.org/#readable-stream-pipe-to">pipeTo</a> with |readable|, |transform|.`[[transformer]]`.`[[t1]]`.`[[writable]]`.
    1. Call <a href="https://streams.spec.whatwg.org/#readable-stream-pipe-to">pipeTo</a> with |transform|.`[[transformer]]`.`[[t2]]`.`[[readable]]` and |writable|.
1. Return |scriptTransform|.

## Attributes ## {#RTCRtpScriptTransformer-attributes}

A RTCRtpScriptTransformer has three private slots called `[[options]]`, `[[readable]]` and `[[writable]]`.

The <dfn attribute for="RTCRtpScriptTransformer">options</dfn> getter steps are:
1. Return [=this=].`[[options]]`.

The <dfn attribute for="RTCRtpScriptTransformer">readable</dfn> getter steps are:
1. Return [=this=].`[[readable]]`.

The <dfn attribute for="RTCRtpScriptTransformer">writable</dfn> getter steps are:
1. Return [=this=].`[[writable]]`.


# Privacy and security considerations # {#privacy}

This API gives Javascript access to the content of media streams. This
is also available from other sources, such as Canvas and WebAudio.

However, streams that are isolated (as specified in
[[WEBRTC-IDENTITY]]) or tainted with another origin, cannot be
accessed using this API, since that would break the isolation rule.

The API will allow access to some aspects of timing information that are
otherwise unavailable, which allows some fingerprinting surface.

The API will give access to encoded media, which means that the JS application
will have full control over what's delivered to internal components like
the packetizer or the decoder. This may require additional care with
auditing how data is handled inside these components.

For instance, packetizers may expect to see data only from trusted encoders,
and may not be audited for reception of data from untrusted sources.

# Examples # {#examples}

See the [explainer document](https://github.com/w3c/webrtc-encoded-transform/blob/master/explainer.md#code-examples).
